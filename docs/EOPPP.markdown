# EOPPP 코드 변환 문서
## C to eFlow 변환기: Python 스크립트 설명서

### 1. 프로젝트 개요
- 본 문서는 C 소스 코드를 분석하여 EOPPP(Elastic On-chip PPP) 아키텍처에서 실행 가능한 eFlow 코드를 자동으로 생성하는 Python 스크립트에 대한 상세 설명서입니다.
- 스크립트는 C 코드의 구조 정보와 컴파일러 중간 표현(GIMPLE) 정보를 담은 두 개의 JSON 파일을 입력받아, 최종적으로 메모리 초기화 파일(.mif) 형식의 eFlow 코드를 출력합니다.

### 2. 전체 아키텍처
- (내용은 원문과 동일하나, 필요 시 별도로 작성)

### 3. C to JSON 코드 규칙

#### 3.1. 전체 원칙
- C 소스 코드를 JSON으로 변환할 때는 각 함수 단위로 코드를 분석합니다.
- 각 함수 안에 포함된 제어문 중에서 if문과 for문을 철저히 분리하여 각각 별도의 리스트(배열)로 구조화합니다.

##### 3.1.1. if문(조건문) JSON 변환 규칙
- **역할**: 함수 내의 모든 if 조건문을 찾아내어, 조건과 해당 조건일 때 수행할 코드 블록을 JSON 형태로 정리합니다.
- **세부 설명**:
  - if_stmts라는 키 아래, 함수 내부 모든 if문을 순서대로 배열로 저장합니다.
  - 각각의 if문은 객체로서, "condition" (조건식)과 "body" (실행될 문장들의 리스트)로 나타냅니다.
  - if문 내부에 else-if나 else가 있다면, 여러 개의 if문 또는 별도의 필드로 나누어 표현할 수 있습니다.

##### 3.1.2. for문(반복문) JSON 변환 규칙
- **역할**: 함수 내 모든 for문을 찾아 초기화, 조건, 증감, 그리고 반복 실행 코드를 각각 추출하여 JSON으로 구조화합니다.
- **세부 설명**:
  - for_loops라는 키 아래, 함수에서 발견되는 for문을 모두 배열로 분리 저장합니다.
  - 각 for문 객체는 "variable" (초기화), "condition" (반복 조건), "increment" (증감식), "body" (실행 코드 리스트)로 세분화하여 담습니다.

#### 3.2. C to JSON 함수별 설명
- **parse_global_variables(self)**:
  - **역할**: C 소스 상단의 전역 변수 선언 및 초기화 정보를 분석합니다.
  - **동작**: 정규표현식으로 변수 선언, 초기화, 배열 여부 등을 파악하여 구조화합니다.
- **parse_function(self, text)**:
  - **역할**: 함수 소스 코드로부터 함수명, 변수 선언, 초기화, 함수 body 등을 분리합니다.
  - **동작**: 함수 시그니처와 바디를 추출하고, #ifdef 같은 조건부 컴파일 코드는 건너뜁니다.
- **parse_initializations(self, init_lines)**:
  - **역할**: 변수 선언 및 초기화 코드 리스트를 사전(dict) 형태로 변환합니다.
  - **동작**: 정규식을 사용해 각 변수의 이름과 초기값을 파악합니다.
- **parse_for_loop(self, body_lines)**:
  - **역할**: 함수 내 for문을 감지하고, 각 요소를 구조화합니다.
  - **동작**: 중괄호, 세미콜론 등을 기준으로 for문 블록을 인식하고 요소별로 분리합니다.
- **parse_if(self, body_lines)**:
  - **역할**: 함수 바디에서 if문을 탐지하고, 조건 및 내부 실행 코드를 분리합니다.
  - **동작**: 중첩 구조도 brace count 방식으로 대응하여 블록을 구조화합니다.
- **extract_main_calls(self)**:
  - **역할**: main 함수 내에서 호출되는 모든 함수 이름들을 추출합니다.
  - **동작**: main 함수 블록 안에서 “함수명(...);” 형태를 찾아 수집합니다.
- **parse_multiple_functions(self)**:
  - **역할**: 소스 전체에서 main에서 호출된 함수만 본격적으로 구조화하여 반환합니다.
  - **동작**: 전역 변수 정보를 먼저 파악한 뒤, main에서 호출된 함수만 상세히 파싱합니다.
- **save_to_json(self, output_file)**:
  - **역할**: 분석 결과 전체를 JSON 파일로 저장합니다.
  - **동작**: 위의 분석 과정을 통해 얻은 구조 데이터를 지정된 파일명으로 저장합니다.

### 4. GIMPLE to JSON 코드 규칙 및 함수 설명
- 이 단계는 GimpleParser 클래스를 통해 C 코드에서 생성된 GIMPLE 중간 표현과 parsed_.json의 C 코드 구조 정보를 결합하여, 더 상세하고 정확한 matched_gimple3.json 파일을 생성하는 과정입니다.

#### 4.1. GIMPLE to JSON 코드 규칙
- **GIMPLE 생성**: GCC 컴파일러를 직접 호출(gcc -fdump-tree-gimple -c ...)하여 C 소스 파일로부터 .gimple 파일을 생성합니다.
- **정보 매칭**: parsed_.json에 있는 상위 수준의 제어문 정보(예: for (i=0; i<iT; i++))와 GIMPLE 코드의 저수준 제어 흐름(예: if (i < iT) goto <L1>;)을 비교하고 매칭합니다.
- **상세 정보 통합**: 매칭된 정보를 바탕으로, 각 함수의 for_loops, if_stmts를 재구성하고, GIMPLE 코드의 모든 실행 라인을 순서대로 all_lines에 추가하여 C 코드와 GIMPLE 코드 간의 완전한 매핑을 제공합니다.

#### 4.2. 함수별 설명
- **_generate_gimple(self)**:
  - **역할**: subprocess 모듈을 사용하여 시스템의 GCC 컴파일러를 호출하고, C 파일로부터 .gimple 파일을 생성합니다.
  - **동작**: GCC가 생성하는 예측 불가능한 파일 이름(예: test.c.003t.gimple)을 찾아내어 test.c.gimple과 같이 일관된 이름으로 변경하는 중요한 처리를 수행합니다. GCC가 설치되지 않았거나 컴파일 오류 발생 시 예외 처리를 포함합니다.
- **parse_and_match_gimple(self)**:
  - **역할**: GIMPLE 파일과 parsed_.json의 내용을 결합하는 핵심 로직입니다.
  - **동작**:
    - GIMPLE 파일을 한 줄씩 읽고, parsed_.json에서 함수별 for 및 if 조건 정보를 미리 추출하여 매칭 준비를 합니다.
    - GIMPLE 텍스트에서 함수 경계(func_name ())를 식별합니다.
    - 함수 내부에서 GIMPLE의 if (...) goto <true_label>; else goto <false_label>; 구문을 파싱합니다.
    - 파싱된 GIMPLE 조건식을 parsed_.json의 for_loops 또는 if_stmts의 조건식과 비교하여 일치하는 항목을 찾습니다.
    - 일치하는 항목을 찾으면, GIMPLE의 레이블(true_label, false_label)을 이용해 반복문과 조건문의 body 부분을 GIMPLE 코드에서 정확히 추출하여 재구성합니다.
    - GIMPLE의 모든 라인을 순서와 함께 all_lines에 저장하여 최종 구조체를 완성합니다.
- **save_to_json(self, output_file)**:
  - **역할**: 위 과정에서 최종적으로 매칭되고 재구성된 데이터를 matched_gimple3.json 파일로 저장합니다.
  - **동작**: 모든 처리가 완료된 후, 중간 산출물인 .gimple 파일을 자동으로 삭제하여 정리합니다.

### 5. JSON to eFlow

#### 5.1. 핵심 아키텍처 규칙
- **기호 실행을 통한 레지스터 매핑 (Register Mapping via Symbolic Execution)**:
  - 스크립트는 GIMPLE 코드를 한 줄씩 기계적으로 번역하는 대신, 기호 실행(Symbolic Execution)에 가까운 방식으로 변수의 값과 상태를 추적합니다.
  - evaluate_rhs_val와 같은 함수를 통해 변수 간의 관계를 해석하고 각 단계에서의 값을 계산합니다.
  - 분석된 결과(변수, 상수, 연산 결과)는 RegMap을 통해 한정된 하드웨어 레지스터(r0~r127)에 직접 매핑됩니다.
  - 모든 연산은 최종적으로 이 레지스터들 간의 조합(예: r3 = r1 + r2)으로 귀결됩니다.
- **상태 기반 GPC 변환 (State-Based GPC Transformation)**:
  - 전체 코드는 순차적인 명령어 변환이 아닌, 프로그램의 특정 상태(State)를 GPC(General Purpose Core) 단위로 정의하고 변환합니다.
  - 예를 들어, GPC 0은 변수의 초기화 상태를, GPC 1은 루프가 한 번 실행된 후의 연산 상태를 나타냅니다.
  - 이 아키텍처는 하드웨어가 두 가지 상태(초기값 설정, 반복 연산)를 전환하며 동작하도록 설계되었으며, 스크립트는 각 상태에 필요한 모든 레지스터 값을 미리 계산하여 .mif 파일에 기록합니다.
- **하드웨어 효율성을 위한 표현식 사전 연산 (Expression Pre-computation for Hardware Efficiency)**:
  - 스크립트는 C 코드를 단순 번역하는 것을 넘어, 하드웨어의 부담을 최소화하기 위해 표현식을 사전에 최대한 연산하고 최적화합니다.
  - 예를 들어, a = b + c; d = a + 1;과 같은 코드가 있을 때, 이를 d = (b + c) + 1로 미리 해석합니다.
  - 그 후 construct_reg_sum과 같은 함수를 통해 최종적으로 필요한 레지스터들의 조합(r4 = (r1 + r2) + r_const_1)을 결정하고, 이 연산을 한 번에 수행할 수 있는 eFlow 명령어를 생성합니다.
  - 이는 하드웨어가 여러 단계의 간단한 명령을 수행하는 대신, 미리 최적화된 복합 연산을 한 사이클에 처리하게 하여 실행 효율을 극대화하는 규칙입니다.

#### 5.2. 함수별 설명
##### 클래스 초기화
- **__init__(self, gimple_json_path, parsed_json_path, output_mif_path, debug)**:
  - **역할**: MIFGenerator 객체의 속성을 초기화합니다.
  - **동작**: 입력 및 출력 파일 경로와 디버그 모드 여부를 인스턴스 변수로 저장합니다. 레지스터 할당 정보를 관리할 RegMap 객체를 생성하고, 함수 및 전역 변수 데이터를 저장할 내부 변수들을 초기화합니다.

##### 내부 헬퍼 메서드 (Utilities)
- **dprint(self, *args, **kwargs)**:
  - **역할**: 디버깅 목적으로 메시지를 출력합니다.
  - **동작**: debug 플래그가 True일 경우에만 print 함수를 호출하여 전달된 메시지를 콘솔에 출력합니다.
- **to_hex32(val)**:
  - **역할**: 주어진 값을 32비트 16진수 문자열로 변환합니다.
  - **동작**: 입력 값을 정수로 변환한 뒤, 32비트 크기에 맞춰 8자리 16진수 문자열(예: 0000000a)로 포맷팅하여 반환합니다. 변환 실패 시 0으로 처리합니다.
- **parse_assignment(line)**:
  - **역할**: 할당문(lhs = rhs;)을 좌변(lhs)과 우변(rhs)으로 분리합니다.
  - **동작**: 정규표현식을 사용하여 = 기호를 기준으로 좌변의 변수명과 우변의 표현식을 추출하여 튜플로 반환합니다.
- **parse_condition_parts(cond)**:
  - **역할**: 조건문(var < 10)을 변수와 표현식으로 분리합니다.
  - **동작**: 정규표현식을 사용하여 비교 연산자(<, >, == 등)를 기준으로 좌변의 변수와 우변의 표현식을 추출합니다.
- **is_temporary_var(var_name) / is_h_constant(var_name)**:
  - **역할**: 변수 이름이 GIMPLE 임시 변수(D.xxxx)인지 또는 특정 상수(h로 시작)인지 확인합니다.
  - **동작**: 정규표현식을 통해 변수 이름의 패턴을 검사하여 True/False를 반환합니다.
- **constants_in_body(for_loops, if_stmts)**:
  - **역할**: for문과 if문 내부에서 사용되는 모든 정수 상수를 추출합니다.
  - **동작**: 제어문 블록 내의 증감식 등에서 var = var + 상수 형태의 패턴을 찾아 모든 고유한 상수들을 집합(set)으로 반환합니다.
- **rhs_vars_in_conditions(conds)**:
  - **역할**: 조건문의 우변(RHS)에 등장하는 변수들을 추출합니다.
  - **동작**: var < other_var와 같은 조건문에서 other_var에 해당하는 변수명을 찾아 집합으로 반환합니다.
- **build_var_expr_map(func)**:
  - **역할**: 변수와 그 변수를 정의하는 수식 간의 매핑(e.g., {'a': 'b + c'})을 생성합니다.
  - **동작**: 함수 내의 모든 할당문을 분석하여, 어떤 변수가 다른 변수들의 합 또는 차로 표현되는지를 찾아 딕셔너리로 구축합니다. 이 맵은 이후 수식 치환에 사용됩니다.
- **one_level_substitute(var, var_map)**:
  - **역할**: build_var_expr_map으로 생성된 맵을 이용해 변수를 한 단계의 수식으로 치환합니다.
  - **동작**: 주어진 변수가 맵에 키로 존재하면 해당 수식을, 없으면 원래 변수명을 반환합니다.
- **evaluate_rhs_val(rhs, current_vals, rhs_neg)**:
  - **역할**: 우변(RHS) 표현식의 현재 값을 계산합니다.
  - **동작**: 변수들의 현재 값을 담고 있는 current_vals 딕셔너리를 참조하여, a + b 또는 c와 같은 수식을 정수 값으로 평가하여 반환합니다.
- **convert_rhs_tmp_vars(rhs)**:
  - **역할**: 우변 표현식에 포함된 모든 GIMPLE 임시 변수명(D.xxxx)을 txxxx 형태로 변환합니다.
  - **동작**: 정규표현식의 re.sub를 사용하여 표현식 내의 모든 임시 변수명을 일괄적으로 변경합니다.
- **construct_reg_sum(mp, gpc, expr)**:
  - **역할**: a + b와 같은 변수 기반 수식을 r1+r2와 같은 레지스터 기반 수식으로 변환합니다.
  - **동작**: 수식을 +로 분리한 뒤, 각 변수/상수에 할당된 레지스터 이름을 RegMap에서 찾아 조합된 레지스터 수식 문자열을 생성합니다.
- **make_cmd_for_declare(var, val_str, regname) / make_cmd_for_assign(var_l, rhs, mp, gpc)**:
  - **역할**: 변수 선언 또는 할당에 대한 최종 eFlow 명령어 문자열을 생성합니다.
  - **동작**: 변수 타입과 값, 할당되는 수식의 형태를 분석하여 LXY(...), ADD(...) 등 하드웨어에 맞는 명령어 코드를 생성합니다.

##### RegMap 클래스
- **역할**: 레지스터 할당 정보를 체계적으로 관리하는 내부 클래스입니다.
- **동작**:
  - **add**: 특정 GPC의 특정 레지스터에 대한 모든 정보(인덱스, 변수명, 설명, 값, 명령어 등)를 내부 테이블에 저장합니다.
  - **set_var/get_var**: 변수명과 레지스터 이름 간의 매핑을 저장하고 조회합니다.
  - **set_const/get_const**: 상수 값과 레지스터 이름 간의 매핑을 저장하고 조회합니다.

##### JSON 로드 및 전처리
- **init_data(self)**:
  - **역할**: 두 개의 입력 JSON 파일(parsed_.json, matched_gimple.json)을 로드하여 데이터를 초기화합니다.
  - **동작**: load_json을 호출하여 파일 내용을 읽고, get_global_variables를 통해 전역 변수 정보를 추출하여 각각 인스턴스 변수에 저장합니다.

##### GPC 빌드 로직
- **build_gpc0(self, func, gpc)**:
  - **역할**: 함수의 초기화 단계(GPC 0)에 대한 레지스터 맵을 구축합니다.
  - **동작**:
    - 초기화 레지스터: C 코드의 변수 초기화 값을 레지스터에 할당하고, 값을 로드하는 LXY 명령어를 생성합니다.
    - 상수 레지스터: 코드 내에서 사용되는 상수들을 별도의 레지스터에 할당합니다.
    - 조건/루프용 상수: 제어 흐름에 필요한 특정 상수(예: 4)를 레지스터에 할당합니다.
    - 나머지 채우기: 사용되지 않은 모든 레지스터를 기본값으로 채웁니다.
- **build_gpc1(self, func, gpc)**:
  - **역할**: 함수의 실행/연산 단계(GPC 1)에 대한 레지스터 맵을 구축합니다. 이 단계는 루프의 한 사이클 동안 발생하는 모든 연산을 정의합니다.
  - **동작**:
    - GPC 0의 상태를 기반으로 변수들의 현재 값을 추적합니다.
    - 증분/본문 처리: 루프 내의 증감문(i++)과 할당문(a = b + c)을 분석합니다. 변수의 값이 어떻게 변하는지 evaluate_rhs_val로 계산하고, 이 연산을 수행하는 eFlow 명령어(ADD 등)와 필요한 레지스터 조합을 construct_reg_sum 등으로 결정하여 RegMap에 추가합니다.
    - 조건문 처리: if나 for의 조건문을 분석하여, 하드웨어의 조건부 분기 명령어(GEZ, GTZ)와 비교에 사용할 레지스터 조합을 결정합니다.
    - 필요한 모든 변수와 상수가 레지스터에 할당되도록 보장하고, 나머지는 기본값으로 채웁니다.

##### MIF 파일 생성 및 저장
- **lines_for_gpc(self, gpc)**:
  - **역할**: 특정 GPC에 대한 .mif 파일의 모든 라인을 생성합니다.
  - **동작**: RegMap에 저장된 해당 GPC의 레지스터 128개 정보를 순회하며, 각 레지스터의 주소, 16진수 값, 그리고 디버깅을 위한 상세한 주석(할당된 변수, 수식, 명령어 등)을 포함한 한 줄의 문자열을 생성합니다.
- **save_mif_file(self, lines)**:
  - **역할**: 생성된 모든 라인을 최종 .mif 파일로 저장합니다.
  - **동작**: .mif 파일의 표준 헤더(DEPTH, WIDTH 등)를 먼저 쓰고, lines_for_gpc를 통해 생성된 모든 GPC의 라인들을 순서대로 쓴 뒤, END;로 파일을 마무리합니다.

##### 실행 엔트리포인트
- **run(self)**:
  - **역할**: 전체 .mif 생성 프로세스를 순서대로 실행하는 메인 메서드입니다.
  - **동작**:
    - init_data()를 호출하여 모든 입력 데이터를 로드합니다.
    - 파싱된 모든 함수에 대해 build_gpc0를 먼저 실행하여 초기화 상태를 모두 빌드합니다.
    - 그 다음, 모든 함수에 대해 build_gpc1을 실행하여 연산 상태를 빌드합니다.
    - 모든 GPC에 대한 헤더 주석과 레지스터 라인을 lines_for_gpc를 통해 생성합니다.
    - save_mif_file을 호출하여 최종 결과를 파일로 저장합니다.

### 6. 폴더 구조
- **eoppp_converter/**:
  - **📜 main.py**
  - **📂 src/**:
    - **📄 c_parse_json.py**
    - **📄 gimpleToJson.py**
    - **📄 makeEflow.py**
  - **📂 examples/**:
    - **📄 fft_test.c**
  - **📂 build/**:
    - **📄 parsed_.json**
    - **📄 matched_gimple.json**
  - **📂 output/**:
    - **📄 fft_test.mif**

### 7. 실행 방법
- **기본 형식**:
  - `py main.py [입력 C 파일 경로] [옵션]`
- **예시**:
  - `py main.py examples/fft_test.c`
- **실행 예시 2: 출력 파일 경로 직접 지정**:
  - `py main.py examples/fft_test.c -o output/my_custom_name.mif`